---
phase: 06-polish-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/auth/refresh.test.ts
  - src/config/storage.test.ts
  - src/api/response.test.ts
  - vitest.config.ts
autonomous: true

must_haves:
  truths:
    - "Token refresh deduplication prevents multiple refresh calls under concurrent requests"
    - "Config loading returns defaults on corrupt or missing file"
    - "Error responses follow consistent markdown format with actionable guidance"
    - "Rate limit errors suggest provider fallback"
    - "All tests pass with npm test command"
  artifacts:
    - path: "src/auth/refresh.test.ts"
      provides: "Token refresh unit tests including deduplication"
      min_lines: 100
    - path: "src/config/storage.test.ts"
      provides: "Config storage unit tests including corruption handling"
      min_lines: 60
    - path: "src/api/response.test.ts"
      provides: "Response formatting unit tests including error scenarios"
      min_lines: 80
    - path: "vitest.config.ts"
      provides: "Vitest configuration for test execution"
  key_links:
    - from: "src/auth/refresh.test.ts"
      to: "src/auth/refresh.ts"
      via: "import getValidAccessToken, isTokenExpired"
      pattern: "from.*refresh"
    - from: "src/config/storage.test.ts"
      to: "src/config/storage.ts"
      via: "import loadConfig"
      pattern: "from.*storage"
---

<objective>
Implement validation test suite for core functionality

Purpose: Verify that exponential backoff, concurrent refresh deduplication, config fallback, and error formatting work correctly in isolation and under stress conditions.
Output: Comprehensive unit test suite covering all Phase 6 success criteria validation scenarios.
</objective>

<execution_context>
@/home/skello/.claude/get-shit-done/workflows/execute-plan.md
@/home/skello/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-polish-validation/06-RESEARCH.md

Key implementation files:
@src/auth/refresh.ts
@src/config/storage.ts
@src/api/response.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up Vitest configuration</name>
  <files>vitest.config.ts, package.json</files>
  <action>
Create vitest.config.ts with the following configuration:
- Type module support for ESM
- Include pattern for `src/**/*.test.ts`
- Coverage excluded (not needed for validation tests)
- Test environment: node

Verify package.json already has vitest as devDependency (it does - vitest@^3.1.3).

The config should be minimal since vitest works well with defaults for TypeScript ESM projects.
  </action>
  <verify>
Run `npm test -- --passWithNoTests` to confirm vitest runs without errors.
  </verify>
  <done>Vitest configuration exists and npm test command works</done>
</task>

<task type="auto">
  <name>Task 2: Create token refresh validation tests</name>
  <files>src/auth/refresh.test.ts</files>
  <action>
Create comprehensive unit tests for token refresh functionality:

**Test cases:**

1. `isTokenExpired` function:
   - Returns false for tokens with time remaining greater than buffer
   - Returns true for tokens expiring within buffer period (60s)
   - Returns true for already expired tokens

2. `getValidAccessToken` function (mock dependencies):
   - Returns immediately for valid (non-expired) tokens
   - Returns null when no tokens stored
   - Throws when no refresh token available

3. Concurrent refresh deduplication (CRITICAL):
   - Setup: Mock token storage to return expired token
   - Mock fetch to simulate refresh with 100ms delay
   - Call getValidAccessToken 3 times concurrently (Promise.all)
   - Assert: fetch called exactly once (deduplication works)
   - Assert: all 3 calls return same token

4. Retry with exponential backoff:
   - Mock first 2 refresh attempts to fail with network error
   - Mock 3rd attempt to succeed
   - Verify all 3 returned tokens are from successful refresh

5. `invalid_grant` handling:
   - Mock refresh to return invalid_grant error
   - Verify error thrown immediately (no retry)
   - Verify error message contains "Re-authentication required"

**Mocking approach:**
- Use vi.mock for fs operations (token storage reads/writes)
- Use vi.spyOn for fetch (refresh calls)
- Clean up all mocks in afterEach

**Important:** The refreshPromises Map is a module-level singleton. Test isolation requires either:
- Running refresh tests sequentially (not .concurrent)
- OR resetting module state between tests

Use `beforeEach(() => vi.resetModules())` to ensure clean state.
  </action>
  <verify>
Run `npm test src/auth/refresh.test.ts` - all tests pass.
  </verify>
  <done>Token refresh tests cover deduplication, retry, and error scenarios</done>
</task>

<task type="auto">
  <name>Task 3: Create config and error response tests</name>
  <files>src/config/storage.test.ts, src/api/response.test.ts</files>
  <action>
**Config storage tests (src/config/storage.test.ts):**

1. `loadConfig` returns defaults when file doesn't exist:
   - Mock fs.readFile to throw ENOENT
   - Verify DEFAULT_CONFIG returned

2. `loadConfig` returns defaults on corrupt JSON:
   - Mock fs.readFile to return "{ invalid json }"
   - Verify DEFAULT_CONFIG returned (no throw)

3. `loadConfig` returns defaults on Zod validation failure:
   - Mock fs.readFile to return valid JSON with invalid values
   - Verify DEFAULT_CONFIG returned

4. `loadConfig` returns parsed config for valid file:
   - Mock fs.readFile with valid config JSON
   - Verify parsed values returned

5. `saveConfig` creates directory and writes atomically:
   - Mock mkdir and writeFile
   - Verify mkdir called with { recursive: true, mode: 0o700 }
   - Verify writeFile writes to .tmp path
   - Verify rename from .tmp to final path

**Response formatting tests (src/api/response.test.ts):**

1. `formatErrorResponse` for 401:
   - Verify contains "## Authentication Error"
   - Verify contains provider-specific re-auth instructions
   - Verify contains `auth --login <provider>`

2. `formatErrorResponse` for 403:
   - Same as 401 (both auth errors)

3. `formatErrorResponse` for 429:
   - Verify contains "## Rate Limited"
   - Verify contains "Wait a few minutes"
   - Verify suggests `auth --default-provider` for fallback

4. `formatErrorResponse` for other status:
   - Verify contains "## Search Error"
   - Verify contains troubleshooting steps

5. `formatSearchResult` with sources:
   - Verify sources formatted as markdown links
   - Verify domain extracted correctly

6. `formatSearchResult` with empty result:
   - Verify "_No results found._" message

7. `parseSearchResponse` deduplicates sources by URL:
   - Pass response with duplicate URLs
   - Verify deduplicated sources array

**Mocking approach:**
- Mock fs module for config tests
- No mocking needed for response tests (pure functions)
  </action>
  <verify>
Run `npm test src/config src/api` - all tests pass.
Run `npm test` - full test suite passes.
  </verify>
  <done>Config loading graceful fallback and error formatting consistency verified by tests</done>
</task>

</tasks>

<verification>
1. `npm test` passes with all tests green
2. `npm run typecheck` passes
3. `npm run lint` passes (tests follow lint rules)
4. Test coverage includes:
   - Token refresh deduplication (concurrent calls)
   - Config corruption graceful fallback
   - Error message consistency (401, 403, 429, other)
</verification>

<success_criteria>
- All unit tests pass
- Token refresh deduplication proven by test (1 fetch for 3 concurrent calls)
- Config loading never throws (always returns valid config)
- Error responses all follow ## Heading format with **To fix:** steps
</success_criteria>

<output>
After completion, create `.planning/phases/06-polish-validation/06-01-SUMMARY.md`
</output>
