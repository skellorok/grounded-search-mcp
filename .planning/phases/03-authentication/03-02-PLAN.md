---
phase: 03-authentication
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/tools/auth.ts
  - src/auth/index.ts
autonomous: false

must_haves:
  truths:
    - "User can start login flow with auth --login or auth --login <provider>"
    - "User can check auth status with auth --status"
    - "User can logout with auth --logout or auth --logout <provider>"
    - "User can set default provider with auth --default-provider <provider>"
    - "Email is masked in MCP responses (jo***@gm***.com format)"
    - "Auth flow shows URL and waits for user to provide authorization code"
  artifacts:
    - path: "src/tools/auth.ts"
      provides: "MCP auth tool with flag-based interface"
      exports: ["registerAuthTool"]
      min_lines: 150
    - path: "src/auth/index.ts"
      provides: "Main auth exports for tool usage"
      exports: ["isAuthenticated", "getValidToken", "login", "logout", "getStatus", "setDefaultProvider", "maskEmail"]
  key_links:
    - from: "src/tools/auth.ts"
      to: "src/auth/index.ts"
      via: "imports auth functions"
      pattern: "from.*auth/index"
    - from: "src/auth/index.ts"
      to: "src/auth/device-flow.ts"
      via: "imports startAuthFlow, exchangeCodeForTokens"
      pattern: "startAuthFlow|exchangeCodeForTokens"
    - from: "src/auth/index.ts"
      to: "src/auth/token-storage.ts"
      via: "imports token persistence"
      pattern: "loadTokens|saveTokens"
---

<objective>
Implement the MCP auth tool with flag-based interface for login, status, logout, and default provider operations.

Purpose: This is the user-facing interface for authentication. Users interact exclusively through this tool to manage their Google credentials.

Output: Fully functional auth tool that supports --login, --status, --logout, and --default-provider flags with proper UX including email masking.
</objective>

<execution_context>
@/home/skello/.claude/get-shit-done/workflows/execute-plan.md
@/home/skello/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-authentication/03-CONTEXT.md
@.planning/phases/03-authentication/03-RESEARCH.md
@.planning/phases/03-authentication/03-01-SUMMARY.md
@src/tools/auth.ts
@src/auth/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement auth module exports</name>
  <files>
    src/auth/index.ts
  </files>
  <action>
Rewrite `src/auth/index.ts` to provide the main auth API:

1. Re-export types from types.ts: ProviderName, ProviderTokens, TokenFile

2. Export `maskEmail(email: string)`:
   - Split email at @
   - Mask local part: first 2 chars + '***'
   - Mask domain name: first 2 chars + '***'
   - Keep TLD unchanged
   - Example: "john.doe@gmail.com" -> "jo***@gm***.com"
   - Handle edge cases: short emails, missing @

3. Export `isAuthenticated(provider?: ProviderName)`:
   - If provider specified: check if that provider has valid tokens
   - If no provider: check if ANY provider has valid tokens
   - Valid = has access_token and expires_at > Date.now()

4. Export `getDefaultProvider()`:
   - Load tokens, return default_provider or 'gemini' if not set

5. Export `setDefaultProvider(provider: ProviderName)`:
   - Load tokens, set default_provider, save

6. Export `getStatus()`:
   - Load tokens
   - Return object with:
     - gemini: { authenticated: boolean, email?: string (masked), expiresAt?: number } or null
     - antigravity: { authenticated: boolean, email?: string (masked), expiresAt?: number } or null
     - defaultProvider: ProviderName

7. Export `login(provider: ProviderName)`:
   - Call startAuthFlow(provider)
   - Return { authUrl, flowState: { codeVerifier, state, provider } }
   - Caller will display URL and handle code input

8. Export `completeLogin(code: string, flowState: AuthFlowState)`:
   - Validate state if provided in code (URL may include state)
   - Call exchangeCodeForTokens(code, flowState.codeVerifier, flowState.provider)
   - Call fetchUserInfo(accessToken)
   - Build ProviderTokens with expires_at calculated from expires_in
   - Call updateProviderTokens(provider, tokens)
   - Return { success: true, email: maskedEmail }

9. Export `logout(provider: ProviderName | 'both')`:
   - If 'both': delete both providers' tokens
   - Otherwise: delete specific provider's tokens
   - Return { success: true, provider }

Import from local modules: device-flow, token-storage, types, providers
  </action>
  <verify>
    npm run typecheck
    npm run lint
  </verify>
  <done>
    - src/auth/index.ts exports all auth functions
    - maskEmail properly masks email addresses
    - isAuthenticated checks token validity
    - login starts OAuth flow and returns URL + state
    - completeLogin exchanges code for tokens and saves them
    - logout clears provider tokens
    - All functions properly typed
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement auth tool with flag-based interface</name>
  <files>
    src/tools/auth.ts
  </files>
  <action>
Rewrite `src/tools/auth.ts` with flag-based interface per CONTEXT.md:

1. Update input schema with Zod:
   ```typescript
   inputSchema: {
     login: z.enum(['gemini', 'antigravity']).optional()
       .describe('Provider to authenticate with. Omit to show provider selection.'),
     status: z.boolean().optional()
       .describe('Show authentication status for all providers'),
     logout: z.enum(['gemini', 'antigravity', 'both']).optional()
       .describe('Provider to log out. Omit to show provider selection.'),
     default_provider: z.enum(['gemini', 'antigravity']).optional()
       .describe('Set the default provider for searches'),
   }
   ```

2. Tool handler logic:
   - If status: return formatted status from getStatus()
   - If logout specified: call logout(), return confirmation
   - If default_provider specified: call setDefaultProvider(), return confirmation
   - If login specified: call login(), return auth URL and instructions
   - If no flags: return help text showing available flags

3. Status format (text response):
   ```
   ## Authentication Status

   **Default provider:** Gemini CLI

   ### Gemini CLI
   Status: Authenticated
   Account: jo***@gm***.com

   ### Antigravity
   Status: Not authenticated
   ```

4. Login format (when user provides provider):
   ```
   ## Authentication Required

   To authenticate with Gemini CLI:

   1. Open this URL in your browser:
      https://accounts.google.com/o/oauth2/v2/auth?...

   2. Sign in with your Google account and authorize the application

   3. Copy the authorization code shown on the page

   4. Reply with the authorization code

   **Note:** This process will time out in 5 minutes.
   ```

5. Help format (no flags):
   ```
   ## Auth Tool

   Manage authentication for Google Search grounding.

   **Usage:**
   - auth --status: Show authentication status
   - auth --login: Start authentication (shows provider menu)
   - auth --login gemini: Authenticate with Gemini CLI
   - auth --login antigravity: Authenticate with Antigravity
   - auth --logout: Log out (shows provider menu)
   - auth --logout gemini: Log out of Gemini CLI
   - auth --logout both: Log out of all providers
   - auth --default-provider gemini: Set default provider
   ```

6. Track active auth flow in module-level variable for code completion

IMPORTANT: All email addresses in responses must use maskEmail()
  </action>
  <verify>
    npm run typecheck
    npm run lint
    npm run build
  </verify>
  <done>
    - auth tool accepts status, login, logout, default_provider flags
    - --status shows formatted status with masked emails
    - --login starts OAuth flow and displays URL + instructions
    - --logout clears tokens for specified provider
    - --default-provider sets the default provider
    - No flags shows help text
    - All emails masked in responses
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete auth tool with login, status, logout, and default-provider operations.
    OAuth flow starts and displays URL for user authentication.
  </what-built>
  <how-to-verify>
1. Build and start MCP inspector:
   ```bash
   npm run build && npm run inspector
   ```

2. Test status (unauthenticated):
   - Call auth tool with `{"status": true}`
   - Should show "Not authenticated" for both providers

3. Test login flow:
   - Call auth tool with `{"login": "gemini"}`
   - Should display auth URL and instructions
   - Open URL in browser, sign in, get authorization code
   - NOTE: Do not enter code yet (that's tested in next task)

4. Test help:
   - Call auth tool with `{}`
   - Should show help text with all available flags

5. Verify no console.log statements (would corrupt stdio):
   - Check src/tools/auth.ts and src/auth/index.ts for console.log
   - Only console.error allowed
  </how-to-verify>
  <resume-signal>Type "approved" if auth tool works as expected, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Build succeeds
npm run build

# Verify auth tool registered
node -e "
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { registerAuthTool } from './build/tools/auth.js';
const server = new McpServer({ name: 'test', version: '1.0.0' });
registerAuthTool(server);
console.log('Auth tool registered successfully');
"
```
</verification>

<success_criteria>
1. auth --status shows authentication status with masked emails
2. auth --login <provider> starts OAuth flow and displays URL
3. auth --logout <provider> clears tokens
4. auth --default-provider <provider> sets default
5. auth (no flags) shows help
6. All emails masked in MCP responses
7. Human verified auth flow starts correctly
</success_criteria>

<output>
After completion, create `.planning/phases/03-authentication/03-02-SUMMARY.md`
</output>
