---
phase: 03-authentication
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/tools/auth.ts
  - src/auth/index.ts
autonomous: false

must_haves:
  truths:
    - "User can start login flow with auth --login or auth --login <provider>"
    - "User can check auth status with auth --status"
    - "User can logout with auth --logout or auth --logout <provider>"
    - "User can set default provider with auth --default-provider <provider>"
    - "User can complete auth by providing authorization code"
    - "Email is masked in MCP responses (jo***@gm***.com format)"
    - "Auth flow shows URL and waits for user to provide authorization code"
  artifacts:
    - path: "src/tools/auth.ts"
      provides: "MCP auth tool with flag-based interface"
      exports: ["registerAuthTool"]
      min_lines: 200
    - path: "src/auth/index.ts"
      provides: "Main auth exports for tool usage"
      exports: ["isAuthenticated", "getValidToken", "login", "logout", "getStatus", "setDefaultProvider", "maskEmail", "completeLogin"]
  key_links:
    - from: "src/tools/auth.ts"
      to: "src/auth/index.ts"
      via: "imports auth functions"
      pattern: "from.*auth/index"
    - from: "src/auth/index.ts"
      to: "src/auth/device-flow.ts"
      via: "imports startAuthFlow, exchangeCodeForTokens"
      pattern: "startAuthFlow|exchangeCodeForTokens"
    - from: "src/auth/index.ts"
      to: "src/auth/token-storage.ts"
      via: "imports token persistence"
      pattern: "loadTokens|saveTokens"
---

<objective>
Implement the MCP auth tool with flag-based interface for login, status, logout, default provider operations, AND authorization code completion.

Purpose: This is the user-facing interface for authentication. Users interact exclusively through this tool to manage their Google credentials and complete OAuth flows.

Output: Fully functional auth tool that supports --login, --status, --logout, --default-provider, and --code flags with proper UX including email masking and complete auth flow handling.
</objective>

<execution_context>
@/home/skello/.claude/get-shit-done/workflows/execute-plan.md
@/home/skello/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-authentication/03-CONTEXT.md
@.planning/phases/03-authentication/03-RESEARCH.md
@.planning/phases/03-authentication/03-01-SUMMARY.md
@src/tools/auth.ts
@src/auth/index.ts
</context>

<requirement_notes>
## ERROR-02 Clarification (Interactive Option)

Per MCP architecture, tools are not interactive. ERROR-02's "offer option to start auth flow" means
providing clear instructions on HOW to authenticate, not an interactive prompt. The implementation
returns a text response with explicit instructions: "Use the auth tool: auth --login <provider>".
This satisfies ERROR-02 within MCP constraints where tools cannot prompt interactively.
</requirement_notes>

<tasks>

<task type="auto">
  <name>Task 1: Implement auth module exports</name>
  <files>
    src/auth/index.ts
  </files>
  <action>
Rewrite `src/auth/index.ts` to provide the main auth API:

1. Re-export types from types.ts: ProviderName, ProviderTokens, TokenFile

2. Export `maskEmail(email: string)`:
   - Split email at @
   - Mask local part: first 2 chars + '***'
   - Mask domain name: first 2 chars + '***'
   - Keep TLD unchanged
   - Example: "john.doe@gmail.com" -> "jo***@gm***.com"
   - Handle edge cases: short emails, missing @

3. Export `isAuthenticated(provider?: ProviderName)`:
   - If provider specified: check if that provider has valid tokens
   - If no provider: check if ANY provider has valid tokens
   - Valid = has access_token and expires_at > Date.now()

4. Export `getDefaultProvider()`:
   - Load tokens, return default_provider or 'gemini' if not set

5. Export `setDefaultProvider(provider: ProviderName)`:
   - Load tokens, set default_provider, save

6. Export `getStatus()`:
   - Load tokens
   - Return object with:
     - gemini: { authenticated: boolean, email?: string (masked), expiresAt?: number } or null
     - antigravity: { authenticated: boolean, email?: string (masked), expiresAt?: number } or null
     - defaultProvider: ProviderName

7. Export `login(provider: ProviderName)`:
   - Call startAuthFlow(provider)
   - Return { authUrl, flowState: { codeVerifier, state, provider } }
   - Caller will display URL and handle code input

8. Export `completeLogin(code: string, flowState: AuthFlowState)`:
   - Validate state if provided in code (URL may include state)
   - Call exchangeCodeForTokens(code, flowState.codeVerifier, flowState.provider)
   - Call fetchUserInfo(accessToken)
   - Build ProviderTokens with expires_at calculated from expires_in
   - Call updateProviderTokens(provider, tokens)
   - Return { success: true, email: maskedEmail }

9. Export `logout(provider: ProviderName | 'both')`:
   - If 'both': delete both providers' tokens
   - Otherwise: delete specific provider's tokens
   - Return { success: true, provider }

Import from local modules: device-flow, token-storage, types, providers
  </action>
  <verify>
    npm run typecheck
    npm run lint
  </verify>
  <done>
    - src/auth/index.ts exports all auth functions
    - maskEmail properly masks email addresses
    - isAuthenticated checks token validity
    - login starts OAuth flow and returns URL + state
    - completeLogin exchanges code for tokens and saves them
    - logout clears provider tokens
    - All functions properly typed
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement complete auth tool with flag-based interface and code completion</name>
  <files>
    src/tools/auth.ts
  </files>
  <action>
Rewrite `src/tools/auth.ts` with flag-based interface per CONTEXT.md, INCLUDING code completion handling:

1. Update input schema with Zod:
   ```typescript
   inputSchema: {
     login: z.enum(['gemini', 'antigravity']).optional()
       .describe('Provider to authenticate with. Omit to show provider selection.'),
     status: z.boolean().optional()
       .describe('Show authentication status for all providers'),
     logout: z.enum(['gemini', 'antigravity', 'both']).optional()
       .describe('Provider to log out. Omit to show provider selection.'),
     default_provider: z.enum(['gemini', 'antigravity']).optional()
       .describe('Set the default provider for searches'),
     code: z.string().optional()
       .describe('Authorization code from Google OAuth (after visiting auth URL)'),
   }
   ```

2. Track active auth flows in module-level Map:
   ```typescript
   const activeAuthFlows = new Map<string, { state: AuthFlowState, createdAt: number }>();
   const AUTH_FLOW_TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes
   ```

3. Tool handler logic:
   - If status: return formatted status from getStatus()
   - If logout specified: call logout(), return confirmation
   - If default_provider specified: call setDefaultProvider(), return confirmation
   - If login specified with code: complete the auth flow (see step 6)
   - If login specified without code: start auth flow (see step 4)
   - If code without login: check for active flow, complete if found
   - If no flags: return help text showing available flags

4. When login is initiated (no code):
   - Generate a flow ID (use provider name)
   - Store flow state in activeAuthFlows with timestamp
   - Return auth URL and instructions

5. Status format (text response):
   ```
   ## Authentication Status

   **Default provider:** Gemini CLI

   ### Gemini CLI
   Status: Authenticated
   Account: jo***@gm***.com

   ### Antigravity
   Status: Not authenticated
   ```

6. When code is provided:
   - Find matching active flow (by provider if login specified, or most recent)
   - If no active flow: return error "No active authentication flow. Start with auth --login first."
   - Check if flow expired (5 min)
   - If expired: return "Authentication flow expired. Please start again with auth --login."
   - Call completeLogin(code, flowState)
   - On success: return success message with masked email
   - On failure: return error with suggestion to retry
   - Clear flow from activeAuthFlows

7. Login format (when user provides provider, no code yet):
   ```
   ## Authentication Required

   To authenticate with Gemini CLI:

   1. Open this URL in your browser:
      https://accounts.google.com/o/oauth2/v2/auth?...

   2. Sign in with your Google account and authorize the application

   3. Copy the authorization code shown on the page

   4. Reply with: auth --login gemini --code YOUR_CODE

   **Note:** This process will time out in 5 minutes.
   ```

8. Handle already-authenticated case:
   - If login requested but provider already authenticated:
   - Return message: "Already authenticated as jo***@gm***.com. To re-authenticate, logout first with auth --logout <provider>."

9. Success message format:
   ```
   ## Authentication Successful

   You are now authenticated with Gemini CLI as jo***@gm***.com.

   Your session will remain active until you log out or tokens are revoked.
   ```

10. Help format (no flags):
   ```
   ## Auth Tool

   Manage authentication for Google Search grounding.

   **Usage:**
   - auth --status: Show authentication status
   - auth --login: Start authentication (shows provider menu)
   - auth --login gemini: Authenticate with Gemini CLI
   - auth --login antigravity: Authenticate with Antigravity
   - auth --login gemini --code CODE: Complete authentication with code
   - auth --logout: Log out (shows provider menu)
   - auth --logout gemini: Log out of Gemini CLI
   - auth --logout both: Log out of all providers
   - auth --default-provider gemini: Set default provider
   ```

IMPORTANT: All email addresses in responses must use maskEmail()
  </action>
  <verify>
    npm run typecheck
    npm run lint
    npm run build
    # Programmatic verification of tool registration and schema
    node -e "
    import('./build/tools/auth.js').then(async (m) => {
      // Verify registerAuthTool is exported
      if (typeof m.registerAuthTool !== 'function') {
        throw new Error('registerAuthTool not exported');
      }
      console.log('registerAuthTool: exported');

      // Create mock server to test registration
      const mockTools = [];
      const mockServer = {
        tool: (name, desc, schema, handler) => {
          mockTools.push({ name, desc, schema });
        }
      };
      m.registerAuthTool(mockServer);

      // Verify tool was registered with correct schema
      const authTool = mockTools.find(t => t.name === 'auth');
      if (!authTool) throw new Error('auth tool not registered');
      console.log('auth tool: registered');

      // Verify schema has required fields
      const shape = authTool.schema.shape || authTool.schema._def?.shape?.() || {};
      const requiredFields = ['login', 'status', 'logout', 'default_provider', 'code'];
      for (const field of requiredFields) {
        if (!shape[field]) throw new Error('Missing schema field: ' + field);
      }
      console.log('schema fields: all present');
      console.log('VERIFICATION PASSED');
    }).catch(e => { console.error('FAILED:', e.message); process.exit(1); });
    "
  </verify>
  <done>
    - auth tool accepts status, login, logout, default_provider, code flags
    - --status shows formatted status with masked emails
    - --login starts OAuth flow and displays URL + instructions
    - --login <provider> --code <code> completes OAuth flow
    - Active auth flows tracked in memory with 5-minute timeout
    - --logout clears tokens for specified provider
    - --default-provider sets the default provider
    - No flags shows help text
    - All emails masked in responses
    - Tool registration verified programmatically
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete auth tool with login, status, logout, default-provider, and code completion operations.
    OAuth flow starts and displays URL for user authentication.
    Auth flow can be completed by providing authorization code.
  </what-built>
  <how-to-verify>
1. Build and start MCP inspector:
   ```bash
   npm run build && npm run inspector
   ```

2. Test status (unauthenticated):
   - Call auth tool with `{"status": true}`
   - Should show "Not authenticated" for both providers

3. Test login flow:
   - Call auth tool with `{"login": "gemini"}`
   - Should display auth URL and instructions
   - Open URL in browser, sign in, get authorization code

4. Test code completion:
   - Call auth tool with `{"login": "gemini", "code": "<your-code>"}`
   - Should show success with masked email

5. Test status (authenticated):
   - Call auth tool with `{"status": true}`
   - Should show "Authenticated" with masked email

6. Test help:
   - Call auth tool with `{}`
   - Should show help text with all available flags

7. Verify no console.log statements (would corrupt stdio):
   - Check src/tools/auth.ts and src/auth/index.ts for console.log
   - Only console.error allowed
  </how-to-verify>
  <resume-signal>Type "approved" if auth tool works as expected, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Build succeeds
npm run build

# Verify auth tool registered
node -e "
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { registerAuthTool } from './build/tools/auth.js';
const server = new McpServer({ name: 'test', version: '1.0.0' });
registerAuthTool(server);
console.log('Auth tool registered successfully');
"
```
</verification>

<success_criteria>
1. auth --status shows authentication status with masked emails
2. auth --login <provider> starts OAuth flow and displays URL
3. auth --login <provider> --code <code> completes OAuth flow
4. auth --logout <provider> clears tokens
5. auth --default-provider <provider> sets default
6. auth (no flags) shows help
7. All emails masked in MCP responses
8. Human verified complete auth flow works
</success_criteria>

<output>
After completion, create `.planning/phases/03-authentication/03-02-SUMMARY.md`
</output>
