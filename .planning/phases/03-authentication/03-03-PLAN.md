---
phase: 03-authentication
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/auth/refresh.ts
  - src/tools/search.ts
  - src/auth/index.ts
autonomous: true

must_haves:
  truths:
    - "Tokens refresh automatically before expiry"
    - "401 errors trigger reactive token refresh"
    - "Concurrent refresh requests are deduplicated (no race conditions)"
    - "grounded_search returns clear error when not authenticated"
    - "Error message includes instructions to authenticate"
    - "Refresh failures after 3 retries suggest re-authentication"
  artifacts:
    - path: "src/auth/refresh.ts"
      provides: "Token refresh with retry and race condition prevention"
      exports: ["getValidAccessToken", "refreshAccessToken"]
    - path: "src/tools/search.ts"
      provides: "Search tool with auth checks"
      contains: "isAuthenticated"
    - path: "src/auth/index.ts"
      provides: "Updated exports including refresh functions"
      exports: ["getValidAccessToken"]
  key_links:
    - from: "src/auth/refresh.ts"
      to: "https://oauth2.googleapis.com/token"
      via: "fetch for token refresh"
      pattern: "oauth2\\.googleapis\\.com/token"
    - from: "src/auth/refresh.ts"
      to: "src/auth/token-storage.ts"
      via: "saves refreshed tokens"
      pattern: "saveTokens|updateProviderTokens"
    - from: "src/tools/search.ts"
      to: "src/auth/index.ts"
      via: "checks authentication"
      pattern: "isAuthenticated|getValidAccessToken"
---

<objective>
Implement token refresh with retry logic and race condition prevention, plus auth error handling in the search tool.

Purpose: Ensures tokens stay valid without user intervention, handles edge cases like concurrent requests, and provides clear feedback when authentication is required.

Output: Automatic token refresh, graceful error handling in search tool, and clear unauthenticated error messages with instructions.
</objective>

<execution_context>
@/home/skello/.claude/get-shit-done/workflows/execute-plan.md
@/home/skello/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-authentication/03-CONTEXT.md
@.planning/phases/03-authentication/03-RESEARCH.md
@.planning/phases/03-authentication/03-01-SUMMARY.md
@src/tools/search.ts
@src/auth/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement token refresh with retry and deduplication</name>
  <files>
    src/auth/refresh.ts
  </files>
  <action>
Create `src/auth/refresh.ts` implementing token refresh:

1. Constants:
   - ACCESS_TOKEN_BUFFER_MS = 60_000 (refresh 60s before expiry)
   - MAX_REFRESH_RETRIES = 3
   - RETRY_BASE_DELAY_MS = 1000

2. Module-level state for deduplication:
   ```typescript
   const refreshPromises = new Map<ProviderName, Promise<ProviderTokens>>();
   ```

3. Export `isTokenExpired(expiresAt: number)`:
   - Return Date.now() >= expiresAt - ACCESS_TOKEN_BUFFER_MS
   - True means token needs refresh (within buffer or past expiry)

4. Export `refreshAccessToken(provider: ProviderName, refreshToken: string)`:
   - POST to https://oauth2.googleapis.com/token
   - Body: refresh_token, client_id, client_secret (from PROVIDER_CONFIGS), grant_type='refresh_token'
   - Headers: Content-Type: application/x-www-form-urlencoded
   - On success: return { access_token, expires_in, ... }
   - On 'invalid_grant' error: throw specific error "Token revoked or expired. Re-authentication required."
   - On other errors: throw with error_description

5. Internal `refreshWithRetry(provider: ProviderName, refreshToken: string)`:
   - Loop up to MAX_REFRESH_RETRIES
   - On success: return result
   - On failure: wait with exponential backoff (RETRY_BASE_DELAY_MS * 2^attempt)
   - After all retries: throw "Max refresh retries exceeded. Re-authentication may be required."

6. Export `getValidAccessToken(provider: ProviderName)`:
   - Load tokens for provider (return null if not authenticated)
   - If not expired: return access_token immediately
   - If no refresh_token: throw "No refresh token. Re-authentication required."
   - Check if refresh already in progress for this provider (refreshPromises.get)
   - If in progress: await existing promise
   - If not: start refresh, store promise in map, await, remove from map on completion
   - On success: update stored tokens with new access_token and expires_at, return access_token
   - CRITICAL: Use .finally() to always remove from map, preventing stuck state

Deduplication pattern (from RESEARCH.md):
```typescript
if (!refreshPromises.has(provider)) {
  const promise = refreshWithRetry(provider, refreshToken)
    .then(async (result) => {
      await updateProviderTokens(provider, {
        ...currentTokens,
        access_token: result.access_token,
        expires_at: calculateExpiresAt(result.expires_in),
      });
      return result;
    })
    .finally(() => {
      refreshPromises.delete(provider);
    });
  refreshPromises.set(provider, promise);
}
return refreshPromises.get(provider)!;
```
  </action>
  <verify>
    npm run typecheck
    npm run lint
  </verify>
  <done>
    - src/auth/refresh.ts exports isTokenExpired, refreshAccessToken, getValidAccessToken
    - Refresh uses exponential backoff with 3 retries
    - Concurrent refresh requests deduplicated via promise caching
    - invalid_grant errors clearly indicate re-auth needed
    - Refreshed tokens saved to storage
  </done>
</task>

<task type="auto">
  <name>Task 2: Update auth index exports and add search tool auth checks</name>
  <files>
    src/auth/index.ts
    src/tools/search.ts
  </files>
  <action>
1. Update `src/auth/index.ts`:
   - Re-export from refresh.ts: getValidAccessToken, isTokenExpired
   - Export constants: ACCESS_TOKEN_BUFFER_MS, MAX_REFRESH_RETRIES

2. Update `src/tools/search.ts` to check authentication:

Current mock implementation returns fake results. Update to:

a) Import auth functions:
   ```typescript
   import { isAuthenticated, getDefaultProvider, getValidAccessToken, maskEmail } from '../auth/index.js';
   ```

b) At start of tool handler, check auth:
   ```typescript
   // Determine provider (from param or default)
   const provider = args.model?.startsWith('antigravity') ? 'antigravity' : getDefaultProvider();

   // Check authentication
   if (!isAuthenticated(provider)) {
     return {
       content: [{
         type: 'text',
         text: `## Not Authenticated

You need to authenticate before using grounded search.

**To authenticate:**
1. Use the auth tool: \`auth --login ${provider}\`
2. Follow the instructions to complete authentication

**Why authentication is required:**
Google Search grounding requires a valid Google account with Gemini API access.`
       }],
       isError: true,
     };
   }
   ```

c) Try to get valid token (handles refresh):
   ```typescript
   let accessToken: string;
   try {
     accessToken = await getValidAccessToken(provider);
   } catch (error) {
     const message = error instanceof Error ? error.message : 'Unknown error';
     return {
       content: [{
         type: 'text',
         text: `## Authentication Error

${message}

**To fix:**
Use \`auth --login ${provider}\` to re-authenticate.`
       }],
       isError: true,
     };
   }
   ```

d) Keep mock search implementation for now (Phase 4 will implement real API):
   ```typescript
   // TODO: Phase 4 will use accessToken to call Gemini API
   // For now, return mock response indicating auth is working
   return {
     content: [{
       type: 'text',
       text: JSON.stringify({
         answer: `[MOCK - Auth OK] Search results for: "${args.query}"`,
         model: args.model ?? 'gemini-2.0-flash',
         thinking_level: args.thinking_level ?? 'low',
         sources: [],
         searchQueries: [],
         _authenticated: true,
         _provider: provider,
       }, null, 2)
     }],
   };
   ```

NOTE: The actual Gemini API integration happens in Phase 4. This plan only adds auth checks and token retrieval.
  </action>
  <verify>
    npm run typecheck
    npm run lint
    npm run build
  </verify>
  <done>
    - src/auth/index.ts re-exports refresh functions
    - grounded_search checks authentication before proceeding
    - Unauthenticated state returns clear error with instructions
    - Token refresh errors handled with clear re-auth message
    - Mock response indicates auth working for testing
  </done>
</task>

<task type="auto">
  <name>Task 3: Add auth completion handling to auth tool</name>
  <files>
    src/tools/auth.ts
  </files>
  <action>
Update `src/tools/auth.ts` to handle authorization code completion:

1. Add new input schema field:
   ```typescript
   code: z.string().optional()
     .describe('Authorization code from Google OAuth (after visiting auth URL)'),
   ```

2. Track active auth flows in module-level Map:
   ```typescript
   const activeAuthFlows = new Map<string, AuthFlowState>();
   ```

3. When login is initiated:
   - Generate a flow ID (could use provider name since only one flow per provider)
   - Store flow state in activeAuthFlows
   - Include flow ID in response instructions

4. When code is provided:
   - If no login flag, check for active flow matching the code's characteristics
   - Or require login + code together: `{"login": "gemini", "code": "4/xxx..."}`
   - Retrieve flow state from activeAuthFlows
   - If no active flow: return error "No active authentication flow. Start with auth --login first."
   - Call completeLogin(code, flowState)
   - On success: return success message with masked email
   - On failure: return error with suggestion to retry
   - Clear flow from activeAuthFlows

5. Handle already-authenticated case:
   - If login requested but provider already authenticated:
   - Return message: "Already authenticated as jo***@gm***.com. To re-authenticate, logout first with auth --logout <provider>."

6. Add timeout handling:
   - When flow is created, store timestamp
   - When code is submitted, check if flow expired (5 min = 300_000 ms)
   - If expired: return "Authentication flow expired. Please start again with auth --login."

Success message format:
```
## Authentication Successful

You are now authenticated with Gemini CLI as jo***@gm***.com.

Your session will remain active until you log out or tokens are revoked.
```
  </action>
  <verify>
    npm run typecheck
    npm run lint
    npm run build
  </verify>
  <done>
    - auth tool accepts code parameter for completing OAuth flow
    - Active auth flows tracked in memory with timeout
    - completeLogin exchanges code for tokens
    - Success shows masked email
    - Expired flows handled gracefully
    - Already authenticated case handled
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Build succeeds
npm run build

# Type check passes
npm run typecheck

# Lint passes
npm run lint

# Test auth flow end-to-end:
npm run inspector

# In inspector:
# 1. auth --status -> shows not authenticated
# 2. auth --login gemini -> shows URL
# 3. Visit URL, get code
# 4. auth --login gemini --code <code> -> authenticates
# 5. auth --status -> shows authenticated with masked email
# 6. grounded_search "test" -> returns mock with _authenticated: true
# 7. auth --logout gemini -> logs out
# 8. grounded_search "test" -> returns error with auth instructions
```
</verification>

<success_criteria>
1. getValidAccessToken returns valid token or throws clear error
2. Token refresh uses exponential backoff with 3 retries
3. Concurrent refresh requests deduplicated
4. grounded_search checks auth before processing
5. Unauthenticated error includes instructions to use auth --login
6. auth tool handles code completion for OAuth flow
7. Flow timeout after 5 minutes
8. All builds and lints pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-authentication/03-03-SUMMARY.md`
</output>
