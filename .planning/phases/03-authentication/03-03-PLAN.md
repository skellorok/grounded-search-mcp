---
phase: 03-authentication
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - src/auth/refresh.ts
  - src/tools/search.ts
autonomous: true

must_haves:
  truths:
    - "Tokens refresh automatically before expiry"
    - "401 errors trigger reactive token refresh"
    - "Concurrent refresh requests are deduplicated (no race conditions)"
    - "grounded_search returns clear error when not authenticated"
    - "Error message includes instructions to authenticate"
    - "Refresh failures after 3 retries suggest re-authentication"
  artifacts:
    - path: "src/auth/refresh.ts"
      provides: "Token refresh with retry and race condition prevention"
      exports: ["getValidAccessToken", "refreshAccessToken", "isTokenExpired"]
    - path: "src/tools/search.ts"
      provides: "Search tool with auth checks"
      contains: "isAuthenticated"
  key_links:
    - from: "src/auth/refresh.ts"
      to: "https://oauth2.googleapis.com/token"
      via: "fetch for token refresh"
      pattern: "oauth2\\.googleapis\\.com/token"
    - from: "src/auth/refresh.ts"
      to: "src/auth/token-storage.ts"
      via: "saves refreshed tokens"
      pattern: "saveTokens|updateProviderTokens"
    - from: "src/tools/search.ts"
      to: "src/auth/index.ts"
      via: "checks authentication"
      pattern: "isAuthenticated|getValidAccessToken"
---

<objective>
Implement token refresh with retry logic and race condition prevention, plus auth error handling in the search tool.

Purpose: Ensures tokens stay valid without user intervention, handles edge cases like concurrent requests, and provides clear feedback when authentication is required.

Output: Automatic token refresh, graceful error handling in search tool, and clear unauthenticated error messages with instructions.
</objective>

<execution_context>
@/home/skello/.claude/get-shit-done/workflows/execute-plan.md
@/home/skello/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-authentication/03-CONTEXT.md
@.planning/phases/03-authentication/03-RESEARCH.md
@.planning/phases/03-authentication/03-01-SUMMARY.md
@.planning/phases/03-authentication/03-02-SUMMARY.md
@src/tools/search.ts
@src/auth/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement token refresh with retry and deduplication</name>
  <files>
    src/auth/refresh.ts
  </files>
  <action>
Create `src/auth/refresh.ts` implementing token refresh:

1. Constants:
   - ACCESS_TOKEN_BUFFER_MS = 60_000 (refresh 60s before expiry)
   - MAX_REFRESH_RETRIES = 3
   - RETRY_BASE_DELAY_MS = 1000

2. Module-level state for deduplication:
   ```typescript
   const refreshPromises = new Map<ProviderName, Promise<ProviderTokens>>();
   ```

3. Export `isTokenExpired(expiresAt: number)`:
   - Return Date.now() >= expiresAt - ACCESS_TOKEN_BUFFER_MS
   - True means token needs refresh (within buffer or past expiry)

4. Export `refreshAccessToken(provider: ProviderName, refreshToken: string)`:
   - POST to https://oauth2.googleapis.com/token
   - Body: refresh_token, client_id, client_secret (from PROVIDER_CONFIGS), grant_type='refresh_token'
   - Headers: Content-Type: application/x-www-form-urlencoded
   - On success: return { access_token, expires_in, ... }
   - On 'invalid_grant' error: throw specific error "Token revoked or expired. Re-authentication required."
   - On other errors: throw with error_description

5. Internal `refreshWithRetry(provider: ProviderName, refreshToken: string)`:
   - Loop up to MAX_REFRESH_RETRIES
   - On success: return result
   - On failure: wait with exponential backoff (RETRY_BASE_DELAY_MS * 2^attempt)
   - After all retries: throw "Max refresh retries exceeded. Re-authentication may be required."

6. Export `getValidAccessToken(provider: ProviderName)`:
   - Load tokens for provider (return null if not authenticated)
   - If not expired: return access_token immediately
   - If no refresh_token: throw "No refresh token. Re-authentication required."
   - Check if refresh already in progress for this provider (refreshPromises.get)
   - If in progress: await existing promise
   - If not: start refresh, store promise in map, await, remove from map on completion
   - On success: update stored tokens with new access_token and expires_at, return access_token
   - CRITICAL: Use .finally() to always remove from map, preventing stuck state

Deduplication pattern (from RESEARCH.md):
```typescript
if (!refreshPromises.has(provider)) {
  const promise = refreshWithRetry(provider, refreshToken)
    .then(async (result) => {
      await updateProviderTokens(provider, {
        ...currentTokens,
        access_token: result.access_token,
        expires_at: calculateExpiresAt(result.expires_in),
      });
      return result;
    })
    .finally(() => {
      refreshPromises.delete(provider);
    });
  refreshPromises.set(provider, promise);
}
return refreshPromises.get(provider)!;
```
  </action>
  <verify>
    npm run typecheck
    npm run lint
  </verify>
  <done>
    - src/auth/refresh.ts exports isTokenExpired, refreshAccessToken, getValidAccessToken
    - Refresh uses exponential backoff with 3 retries
    - Concurrent refresh requests deduplicated via promise caching
    - invalid_grant errors clearly indicate re-auth needed
    - Refreshed tokens saved to storage
  </done>
</task>

<task type="auto">
  <name>Task 2: Update auth index exports and add search tool auth checks</name>
  <files>
    src/auth/index.ts
    src/tools/search.ts
  </files>
  <action>
1. Update `src/auth/index.ts`:
   - Re-export from refresh.ts: getValidAccessToken, isTokenExpired
   - Export constants: ACCESS_TOKEN_BUFFER_MS, MAX_REFRESH_RETRIES

2. Update `src/tools/search.ts` to check authentication:

Current mock implementation returns fake results. Update to:

a) Import auth functions:
   ```typescript
   import { isAuthenticated, getDefaultProvider, getValidAccessToken, maskEmail } from '../auth/index.js';
   ```

b) At start of tool handler, check auth:
   ```typescript
   // Determine provider (from param or default)
   const provider = args.model?.startsWith('antigravity') ? 'antigravity' : getDefaultProvider();

   // Check authentication
   if (!isAuthenticated(provider)) {
     return {
       content: [{
         type: 'text',
         text: `## Not Authenticated

You need to authenticate before using grounded search.

**To authenticate:**
1. Use the auth tool: \`auth --login ${provider}\`
2. Follow the instructions to complete authentication

**Why authentication is required:**
Google Search grounding requires a valid Google account with Gemini API access.`
       }],
       isError: true,
     };
   }
   ```

c) Try to get valid token (handles refresh) with validation:
   ```typescript
   let accessToken: string;
   try {
     const token = await getValidAccessToken(provider);
     // Validate token is non-empty string
     if (!token || typeof token !== 'string' || token.trim() === '') {
       throw new Error('Invalid access token received');
     }
     accessToken = token;
   } catch (error) {
     const message = error instanceof Error ? error.message : 'Unknown error';
     return {
       content: [{
         type: 'text',
         text: `## Authentication Error

${message}

**To fix:**
Use \`auth --login ${provider}\` to re-authenticate.`
       }],
       isError: true,
     };
   }
   ```

d) Keep mock search implementation for now (Phase 4 will implement real API):
   ```typescript
   // TODO: Phase 4 will use accessToken to call Gemini API
   // For now, return mock response indicating auth is working
   return {
     content: [{
       type: 'text',
       text: JSON.stringify({
         answer: `[MOCK - Auth OK] Search results for: "${args.query}"`,
         model: args.model ?? 'gemini-2.0-flash',
         thinking_level: args.thinking_level ?? 'low',
         sources: [],
         searchQueries: [],
         _authenticated: true,
         _provider: provider,
         _tokenValid: true,
       }, null, 2)
     }],
   };
   ```

NOTE: The actual Gemini API integration happens in Phase 4. This plan only adds auth checks and token retrieval with validation.
  </action>
  <verify>
    npm run typecheck
    npm run lint
    npm run build
  </verify>
  <done>
    - src/auth/index.ts re-exports refresh functions
    - grounded_search checks authentication before proceeding
    - Unauthenticated state returns clear error with instructions
    - Token refresh errors handled with clear re-auth message
    - Access token validated as non-empty before use
    - Mock response indicates auth working for testing
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Build succeeds
npm run build

# Type check passes
npm run typecheck

# Lint passes
npm run lint

# Test auth flow end-to-end:
npm run inspector

# In inspector:
# 1. auth --status -> shows authenticated (from 03-02)
# 2. grounded_search "test" -> returns mock with _authenticated: true, _tokenValid: true
# 3. auth --logout gemini -> logs out
# 4. grounded_search "test" -> returns error with auth instructions
```
</verification>

<success_criteria>
1. getValidAccessToken returns valid token or throws clear error
2. Token refresh uses exponential backoff with 3 retries
3. Concurrent refresh requests deduplicated
4. grounded_search checks auth before processing
5. Access token validated before use (non-empty check)
6. Unauthenticated error includes instructions to use auth --login
7. All builds and lints pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-authentication/03-03-SUMMARY.md`
</output>
