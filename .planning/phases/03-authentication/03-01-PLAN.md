---
phase: 03-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/auth/providers.ts
  - src/auth/types.ts
  - src/auth/token-storage.ts
  - src/auth/device-flow.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "PKCE challenge generates valid code_verifier and code_challenge"
    - "Auth URL is correctly formed with all required OAuth parameters"
    - "Token exchange returns access_token and refresh_token"
    - "Tokens persist to disk and survive server restarts"
    - "Token file has secure permissions (0o600)"
  artifacts:
    - path: "src/auth/providers.ts"
      provides: "OAuth credentials for Gemini CLI and Antigravity"
      exports: ["PROVIDER_CONFIGS", "ProviderConfig"]
    - path: "src/auth/types.ts"
      provides: "Auth-specific TypeScript types"
      exports: ["ProviderTokens", "TokenFile", "AuthFlowState"]
    - path: "src/auth/token-storage.ts"
      provides: "Token persistence with Zod validation"
      exports: ["loadTokens", "saveTokens", "getTokenFilePath"]
    - path: "src/auth/device-flow.ts"
      provides: "PKCE auth flow implementation"
      exports: ["startAuthFlow", "exchangeCodeForTokens", "fetchUserInfo"]
  key_links:
    - from: "src/auth/device-flow.ts"
      to: "src/auth/providers.ts"
      via: "imports PROVIDER_CONFIGS"
      pattern: "PROVIDER_CONFIGS\\["
    - from: "src/auth/token-storage.ts"
      to: "src/auth/types.ts"
      via: "imports TokenFile type"
      pattern: "TokenFileSchema"
    - from: "src/auth/device-flow.ts"
      to: "https://oauth2.googleapis.com/token"
      via: "fetch for token exchange"
      pattern: "oauth2\\.googleapis\\.com/token"
---

<objective>
Build the core authentication infrastructure for OAuth device code flow with both Gemini CLI and Antigravity providers.

Purpose: Establishes the foundation for all auth operations - provider configs, PKCE flow, token persistence. Without this, no authentication is possible.

Output: Working OAuth infrastructure that can generate auth URLs, exchange codes for tokens, and persist tokens securely to disk.
</objective>

<execution_context>
@/home/skello/.claude/get-shit-done/workflows/execute-plan.md
@/home/skello/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-authentication/03-CONTEXT.md
@.planning/phases/03-authentication/03-RESEARCH.md
@src/types/index.ts
@src/auth/index.ts
</context>

<requirement_notes>
## AUTH-02 Clarification (Device Flow vs Loopback)

Per CONTEXT.md: "MCP servers cannot spawn loopback servers (stdio transport) — device code flow only"

AUTH-02's "Antigravity loopback flow" is NOT implementable in MCP architecture. The device code flow
with paste-back of authorization code is the ONLY possible flow. This implementation satisfies AUTH-02
within MCP constraints. The redirect_uri 'https://codeassist.google.com/authcode' displays the auth
code for the user to paste back — this is the MCP-compatible equivalent of a loopback flow.
</requirement_notes>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create auth types/providers</name>
  <files>
    package.json
    src/auth/types.ts
    src/auth/providers.ts
  </files>
  <action>
1. Install required packages:
   ```bash
   npm install pkce-challenge env-paths
   ```

2. Create `src/auth/types.ts` with:
   - `ProviderName` type: `'gemini' | 'antigravity'`
   - `ProviderTokens` interface: access_token, refresh_token (optional), expires_at, email (optional)
   - `TokenFile` interface: gemini (optional ProviderTokens), antigravity (optional ProviderTokens), default_provider (optional ProviderName)
   - `AuthFlowState` interface: codeVerifier, state, provider, expiresAt
   - Zod schemas for all types for runtime validation (ProviderTokensSchema, TokenFileSchema)
   - Export both types and schemas

3. Create `src/auth/providers.ts` with:
   - `ProviderConfig` interface: clientId, clientSecret, scopes (string[]), redirectUri, name
   - `PROVIDER_CONFIGS` object with configs for both providers:
     - gemini: clientId='681255809395-oo8ft2oprdrnp9e3aqf6av3hmdib135j.apps.googleusercontent.com', clientSecret='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', scopes=['https://www.googleapis.com/auth/cloud-platform', 'https://www.googleapis.com/auth/userinfo.email', 'https://www.googleapis.com/auth/userinfo.profile'], redirectUri='https://codeassist.google.com/authcode', name='Gemini CLI'
     - antigravity: clientId='1071006060591-tmhssin2h21lcre235vtolojh4g403ep.apps.googleusercontent.com', clientSecret='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', scopes=['https://www.googleapis.com/auth/cloud-platform', 'https://www.googleapis.com/auth/userinfo.email', 'https://www.googleapis.com/auth/userinfo.profile', 'https://www.googleapis.com/auth/cclog', 'https://www.googleapis.com/auth/experimentsandconfigs'], redirectUri='https://codeassist.google.com/authcode', name='Antigravity'

NOTE: These are public OAuth client credentials from Gemini CLI and OpenCode. They are embedded in open-source code and not secrets.
  </action>
  <verify>
    npm run typecheck
    npm run lint
  </verify>
  <done>
    - pkce-challenge and env-paths in package.json dependencies
    - src/auth/types.ts exports ProviderName, ProviderTokens, TokenFile, AuthFlowState types and schemas
    - src/auth/providers.ts exports PROVIDER_CONFIGS with both provider configurations
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement token storage with Zod validation</name>
  <files>
    src/auth/token-storage.ts
  </files>
  <action>
Create `src/auth/token-storage.ts` implementing secure token persistence:

1. Import env-paths and configure for 'google-search-mcp' with suffix: '' (gives ~/.config/google-search-mcp on Linux)

2. Export `getTokenFilePath()`: Returns path to tokens.json using env-paths config directory

3. Export `loadTokens()`:
   - Read tokens.json from config directory
   - Parse JSON and validate with TokenFileSchema
   - Return TokenFile on success, null on ENOENT
   - On parse/validation error: backup to tokens.json.bak, return null
   - Use try/catch for all errors

4. Export `saveTokens(tokens: TokenFile)`:
   - Ensure config directory exists with mode 0o700
   - Write to temp file first (tokens.json.tmp)
   - Set file mode to 0o600 (owner read/write only)
   - Atomic rename temp to tokens.json
   - Use fs/promises for all operations

5. Export helper functions:
   - `getProviderTokens(provider: ProviderName)`: Load tokens, return specific provider's tokens or null
   - `updateProviderTokens(provider: ProviderName, tokens: ProviderTokens)`: Load, update specific provider, save
   - `deleteProviderTokens(provider: ProviderName)`: Load, delete specific provider, save

CRITICAL: Always use fs/promises (not fs sync methods). Always set secure permissions.
  </action>
  <verify>
    npm run typecheck
    npm run lint
    # Manual test: Create a simple script that calls saveTokens then loadTokens
  </verify>
  <done>
    - src/auth/token-storage.ts exists with all exported functions
    - Token file path uses XDG-compliant directory via env-paths
    - File permissions set to 0o600 for token file, 0o700 for directory
    - Atomic write via temp file + rename
    - Corrupt file handling with backup
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement PKCE device code flow</name>
  <files>
    src/auth/device-flow.ts
  </files>
  <action>
Create `src/auth/device-flow.ts` implementing the OAuth flow:

1. Import pkce-challenge (default import, async function)
2. Import crypto from 'node:crypto' for state generation

3. Export `startAuthFlow(provider: ProviderName)`:
   - Generate PKCE challenge via `await pkceChallenge()` - returns { code_verifier, code_challenge }
   - Generate state via `crypto.randomBytes(32).toString('hex')`
   - Build auth URL with URLSearchParams:
     - client_id from PROVIDER_CONFIGS[provider]
     - redirect_uri from PROVIDER_CONFIGS[provider]
     - response_type: 'code'
     - scope: provider scopes joined with space
     - access_type: 'offline' (required for refresh token)
     - code_challenge: from PKCE
     - code_challenge_method: 'S256'
     - state: generated state
     - prompt: 'consent' (forces refresh token grant)
   - Return { authUrl, codeVerifier, state, provider }

4. Export `exchangeCodeForTokens(code: string, codeVerifier: string, provider: ProviderName)`:
   - POST to https://oauth2.googleapis.com/token
   - Body as URLSearchParams: code, client_id, client_secret, redirect_uri, grant_type='authorization_code', code_verifier
   - Headers: Content-Type: application/x-www-form-urlencoded
   - Parse response JSON
   - On error (!response.ok): throw Error with error_description or error from response
   - Return { access_token, refresh_token, expires_in, token_type, scope }

5. Export `fetchUserInfo(accessToken: string)`:
   - GET https://www.googleapis.com/oauth2/v1/userinfo
   - Headers: Authorization: Bearer {accessToken}
   - Return { email, name, picture }

6. Export helper `calculateExpiresAt(expiresIn: number)`:
   - Return Date.now() + (expiresIn * 1000)

All fetch calls should have proper error handling. Use native fetch (Node 18+).
  </action>
  <verify>
    npm run typecheck
    npm run lint
  </verify>
  <done>
    - src/auth/device-flow.ts exports startAuthFlow, exchangeCodeForTokens, fetchUserInfo, calculateExpiresAt
    - PKCE challenge generated with pkce-challenge package
    - Auth URL includes all required OAuth parameters including prompt: 'consent'
    - Token exchange uses proper Content-Type and includes code_verifier
    - User info endpoint returns email for status display
    - All functions properly typed
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Build succeeds
npm run build

# Type check passes
npm run typecheck

# Lint passes
npm run lint

# Verify exports are available
node -e "import('./build/auth/providers.js').then(m => console.log(Object.keys(m)))"
node -e "import('./build/auth/token-storage.js').then(m => console.log(Object.keys(m)))"
node -e "import('./build/auth/device-flow.js').then(m => console.log(Object.keys(m)))"
```
</verification>

<success_criteria>
1. pkce-challenge and env-paths packages installed
2. Provider configs exported with both Gemini CLI and Antigravity credentials
3. Token storage can save and load tokens with secure file permissions
4. PKCE auth flow generates valid auth URLs with all required parameters
5. Token exchange function ready to receive authorization codes
6. All modules compile and pass lint
</success_criteria>

<output>
After completion, create `.planning/phases/03-authentication/03-01-SUMMARY.md`
</output>
