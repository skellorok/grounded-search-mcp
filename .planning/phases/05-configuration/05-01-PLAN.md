---
phase: 05-configuration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config/types.ts
  - src/config/storage.ts
  - src/config/defaults.ts
  - src/config/index.ts
  - src/tools/config.ts
  - src/tools/index.ts
  - src/api/response.ts
  - src/api/search.ts
autonomous: true

must_haves:
  truths:
    - "User can set config values with `config --set key=value`"
    - "User can view current config with `config --show`"
    - "User can reset config with `config --reset`"
    - "Config persists across MCP server restarts"
    - "Search response shows provider and model used"
  artifacts:
    - path: "src/config/types.ts"
      provides: "ConfigFile interface and Zod schema with defaults"
      exports: ["ConfigFileSchema", "ConfigFile"]
    - path: "src/config/storage.ts"
      provides: "Load/save functions with XDG paths"
      exports: ["loadConfig", "saveConfig", "getConfigFilePath"]
    - path: "src/config/defaults.ts"
      provides: "Default values and validation constants"
      exports: ["DEFAULT_CONFIG", "CONFIG_KEYS"]
    - path: "src/tools/config.ts"
      provides: "Config tool with flag-based interface"
      exports: ["registerConfigTool"]
    - path: "src/api/response.ts"
      provides: "Request metadata formatting"
      exports: ["formatRequestDetails"]
  key_links:
    - from: "src/tools/config.ts"
      to: "src/config/storage.ts"
      via: "loadConfig/saveConfig calls"
      pattern: "loadConfig|saveConfig"
    - from: "src/api/search.ts"
      to: "src/config/storage.ts"
      via: "loadConfig for default values"
      pattern: "loadConfig"
    - from: "src/api/response.ts"
      to: "formatSearchResult"
      via: "adds Request Details section"
      pattern: "Request Details"
---

<objective>
Implement configuration persistence and response transparency for gemini-search-mcp.

Purpose: Enable users to persist their search preferences (default provider, thinking level) across sessions and see what provider/model was used for each search.

Output:
- `src/config/` module with types, storage, and defaults (parallel to `src/auth/`)
- `config` tool with flag-based interface (`--set`, `--get`, `--reset`, `--show`)
- Response metadata showing provider and model in search results
</objective>

<execution_context>
@/home/skello/.claude/get-shit-done/workflows/execute-plan.md
@/home/skello/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-configuration/05-CONTEXT.md
@.planning/phases/05-configuration/05-RESEARCH.md

# Existing patterns to mirror
@src/auth/types.ts
@src/auth/token-storage.ts
@src/tools/auth.ts
@src/api/response.ts
@src/api/search.ts
@src/tools/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create config module with types, storage, and defaults</name>
  <files>
    src/config/types.ts
    src/config/storage.ts
    src/config/defaults.ts
    src/config/index.ts
  </files>
  <action>
Create the config module parallel to the auth module structure:

**src/config/types.ts:**
- Define `ConfigFile` interface with fields from CONTEXT.md:
  - `version`: number (schema version, default 1)
  - `defaultProvider`: 'antigravity' | 'gemini' (default 'antigravity')
  - `defaultThinking`: 'high' | 'low' | 'none' (default 'high')
  - `includeThoughts`: boolean (default false)
  - `timeout`: number in ms (default 60000, min 1000, max 300000)
  - `verbose`: boolean (default false)
- Create `ConfigFileSchema` using Zod with `.default()` for each field
- Use `z.infer<typeof ConfigFileSchema>` for type
- Add custom error messages for enum fields (see RESEARCH.md Pattern 1)

**src/config/storage.ts:**
- Mirror pattern from `src/auth/token-storage.ts`
- Use `env-paths` for XDG-compliant path: `~/.config/google-search-mcp/config.json`
- `getConfigFilePath()`: Return config file path
- `loadConfig()`: Use `safeParse` (not `parse`) - warn + return defaults on invalid (NEVER throw)
- `saveConfig()`: Atomic write (temp file + rename), pretty JSON with 2-space indent
- Handle ENOENT gracefully (first run returns defaults)

**src/config/defaults.ts:**
- Export `DEFAULT_CONFIG` generated via `ConfigFileSchema.parse({})`
- Export `CONFIG_KEYS` object with valid values for each key (for --show display)
- Export `CURRENT_CONFIG_VERSION = 1`

**src/config/index.ts:**
- Re-export all public types and functions
  </action>
  <verify>
- `npm run typecheck` passes
- `npm run lint` passes
- Config module exports are accessible from `src/config/index.js`
  </verify>
  <done>
Config module exists with types, storage (safeParse + atomic writes), and defaults. Pattern mirrors auth module structure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create config tool with flag-based interface</name>
  <files>
    src/tools/config.ts
    src/tools/index.ts
  </files>
  <action>
Create the config tool following the pattern from `src/tools/auth.ts`:

**src/tools/config.ts:**
- Register tool named `config` with description "Manage search configuration preferences"
- Parameters (Zod schema):
  - `set`: `z.array(z.string()).optional()` - Set config values (key=value format, supports multiple)
  - `get`: `z.string().optional()` - Get specific config value by key
  - `reset`: `z.union([z.boolean(), z.string()]).optional()` - Reset all (true) or specific key (string)
  - `show`: `z.boolean().optional()` - Show all current settings with defaults and valid options

- Handler logic (order matters for mutual exclusivity):
  1. `--show`: Display current config with sections for each setting showing: current value, default value, valid options
  2. `--get key`: Load config, return value for key (error if invalid key)
  3. `--reset` / `--reset key`: Reset all to defaults or specific key, save, confirm
  4. `--set key=value` (array): Parse each, validate with Zod, save, confirm
  5. No flags: Show help text

- Formatting functions (markdown output like auth tool):
  - `formatShowConfig()`: "## Configuration" with current/default/valid for each setting
  - `formatGetResult()`: "## {key}" with current value
  - `formatSetSuccess()`: "## Configuration Updated" with changes made
  - `formatResetSuccess()`: "## Configuration Reset" with what was reset
  - `formatHelp()`: "## Config Tool" with usage examples
  - `formatError()`: "## Error" with message

- Validation:
  - For `--set`, parse `key=value` format, reject malformed input
  - Validate values using Zod partial schema (just the field being set)
  - Clear error messages on invalid values (show valid options)

**src/tools/index.ts:**
- Import and call `registerConfigTool(server)` from config.ts
  </action>
  <verify>
- `npm run typecheck` passes
- `npm run lint` passes
- `npm run build` succeeds
- Tool appears in MCP tool list when server runs
  </verify>
  <done>
Config tool registered with flag-based interface (--set, --get, --reset, --show). Validation rejects invalid values with clear error messages.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add response metadata and integrate config with search</name>
  <files>
    src/api/response.ts
    src/api/search.ts
  </files>
  <action>
Add Request Details section to search responses and integrate config loading:

**src/api/response.ts:**
- Define `RequestMetadata` interface:
  ```typescript
  interface RequestMetadata {
    provider: ProviderName;
    model: string;
    responseTime?: number;  // Only when verbose=true
    fallbackUsed?: boolean;
    thinkingLevel?: 'high' | 'low' | 'none';
  }
  ```
- Add `formatRequestDetails(metadata: RequestMetadata): string` function:
  - Returns markdown section `### Request Details` with bullet list
  - Always includes: Provider (display name), Model
  - Conditionally includes: "Fallback provider used" if `fallbackUsed=true`
  - Conditionally includes: Response time if `responseTime` provided
- Modify `formatSearchResult()` signature to accept optional `metadata?: RequestMetadata`
- Insert Request Details section after Sources, before Search Queries Used (per CONTEXT.md)

**src/api/search.ts:**
- Import `loadConfig` from `../config/index.js`
- In `searchWithFallback()`:
  - Load config at start: `const config = await loadConfig()`
  - Use `config.defaultProvider` instead of hardcoded 'antigravity'
  - Use `config.defaultThinking` as default when `options.thinking` not specified
  - Track which provider was used and whether fallback occurred
  - Track response time when `config.verbose` is true: `const startTime = Date.now()`
  - Pass metadata to `formatSearchResult()` for successful responses
- For error responses:
  - Include attempt chain in error messages ("Tried: antigravity (failed), gemini (failed)")
  - This helps users understand fallback behavior

- Export `SearchResultWithMetadata` type for downstream use if needed
  </action>
  <verify>
- `npm run typecheck` passes
- `npm run lint` passes
- `npm run build` succeeds
- Search responses include "### Request Details" section with provider/model
  </verify>
  <done>
Search responses include Request Details section showing provider and model. Config defaults are loaded and applied to search behavior.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Type safety:** `npm run typecheck` passes with no errors
2. **Lint:** `npm run lint` passes
3. **Build:** `npm run build` succeeds
4. **Config module structure:**
   - `src/config/types.ts` exports ConfigFileSchema and ConfigFile type
   - `src/config/storage.ts` exports loadConfig, saveConfig, getConfigFilePath
   - `src/config/defaults.ts` exports DEFAULT_CONFIG, CONFIG_KEYS
5. **Config tool:**
   - Tool appears in MCP tool list
   - `config --show` displays all settings with current/default/valid options
   - `config --set defaultProvider=gemini` updates config file
   - `config --reset` restores all defaults
6. **Response metadata:**
   - Search results include `### Request Details` section
   - Provider and model always shown
   - Fallback noted when used
</verification>

<success_criteria>
- Config persists in `~/.config/google-search-mcp/config.json`
- Invalid config file doesn't crash server (warn + use defaults)
- Config tool provides clear markdown output like auth tool
- Search responses show what provider/model was used
- All existing tests pass (if any exist)
</success_criteria>

<output>
After completion, create `.planning/phases/05-configuration/05-01-SUMMARY.md` using the summary template.
</output>
