---
phase: 06.1-uat-gap-closure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/response.ts
  - src/api/search.ts
autonomous: true

must_haves:
  truths:
    - "Fallback reason appears in Request Details when fallback provider used"
    - "Non-auth errors (404, 500, timeout, rate limit) trigger fallback to secondary provider"
    - "Both providers failing returns combined error with WebSearch suggestion"
  artifacts:
    - path: "src/api/response.ts"
      provides: "RequestMetadata with fallbackReason field"
      contains: "fallbackReason?: string"
    - path: "src/api/search.ts"
      provides: "Expanded fallback triggers and reason tracking"
      contains: "!searchResult.success"
  key_links:
    - from: "src/api/search.ts"
      to: "src/api/response.ts"
      via: "RequestMetadata type import"
      pattern: "fallbackReason"
---

<objective>
Fix fallback behavior to surface error reasons and trigger on all errors, not just auth errors.

Purpose: Users need to know WHY the primary provider failed (capacity, auth, 404, etc.) for debugging. Non-auth errors currently return immediately without trying the fallback provider.

Output: Modified search.ts and response.ts with fallback reason tracking and expanded error triggers.
</objective>

<execution_context>
@/home/skello/.claude/get-shit-done/workflows/execute-plan.md
@/home/skello/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06.1-uat-gap-closure/06.1-CONTEXT.md
@.planning/phases/06.1-uat-gap-closure/06.1-RESEARCH.md

@src/api/response.ts
@src/api/search.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add fallbackReason to RequestMetadata type</name>
  <files>src/api/response.ts</files>
  <action>
Add `fallbackReason?: string` field to the RequestMetadata interface (after fallbackUsed).

Update `formatRequestDetails()` to display the fallback reason:
- If `metadata.fallbackReason` exists, show `- **Fallback:** ${fallbackReason}` (e.g., "429 (rate limited)")
- Remove the generic "Fallback provider used" line when reason is available
- Keep generic line as fallback if reason is undefined

Example output when fallback is used:
```
- **Fallback:** 429 (rate limited)
```

NOT:
```
- **Note:** Fallback provider used
```
  </action>
  <verify>Run `npm run typecheck` - no type errors</verify>
  <done>RequestMetadata type has fallbackReason field, formatRequestDetails displays it correctly</done>
</task>

<task type="auto">
  <name>Task 2: Expand fallback triggers and track reason</name>
  <files>src/api/search.ts</files>
  <action>
Modify `searchWithFallback()` function (around lines 580-650) to:

1. **Track fallback reason**: Add `lastErrorReason: string | undefined` variable alongside `lastError`.

2. **Extract reason from errors**: Create helper function `extractFallbackReason(errorResult: string): string`:
   - Match error heading: `errorResult.match(/^## (.+?)[\n\r]/)`
   - Extract status code if present: `errorResult.match(/\*\*Status:\*\* (\d+)/)`
   - Return formatted string: `"429 (rate limited)"` or just heading if no status

3. **Use success boolean for fallback (Antigravity section, ~line 599-603)**:
   Current code already uses `if (searchResult.success)` - good.
   Add: Extract reason before `continue`:
   ```typescript
   if (!searchResult.success) {
     lastError = searchResult.result;
     lastErrorReason = extractFallbackReason(searchResult.result);
     continue;
   }
   ```

4. **Use success boolean for fallback (Gemini CLI section, ~line 615-621)**:
   Replace the string check `if (searchResult.result.startsWith('## Authentication Error'))` with:
   ```typescript
   if (!searchResult.success) {
     lastError = searchResult.result;
     lastErrorReason = extractFallbackReason(searchResult.result);
     continue;
   }
   ```

5. **Pass reason to addMetadataToResult**: Update both success return paths to pass `lastErrorReason`:
   ```typescript
   return addMetadataToResult(searchResult, fallbackUsed, fallbackUsed ? lastErrorReason : undefined);
   ```

6. **Update addMetadataToResult signature** (~line 468):
   ```typescript
   function addMetadataToResult(
     searchResult: SearchResultWithMetadata,
     fallbackUsed: boolean,
     fallbackReason?: string,
   ): string {
   ```
   Pass the reason when calling `formatSearchResult()` - add it to the metadata object.

7. **Update metadata object construction** in addMetadataToResult:
   Add `fallbackReason` to the RequestMetadata object passed to formatSearchResult.

8. **Both providers fail case**: When returning `lastError` at the bottom, append WebSearch suggestion:
   ```typescript
   if (lastError) {
     return `${lastError}\n\n---\n\n**Tip:** Use Claude's built-in WebSearch tool as a fallback for this query.`;
   }
   ```
  </action>
  <verify>
Run `npm run typecheck` - no type errors.
Run `npm test` - all existing tests pass.
  </verify>
  <done>
searchWithFallback triggers fallback for any error (not just auth), tracks reason, surfaces reason in response metadata, suggests WebSearch when both providers fail.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with no errors
2. `npm test` passes (all 57 existing tests)
3. Manual inspection: RequestMetadata interface has fallbackReason field
4. Manual inspection: formatRequestDetails shows fallback reason when available
5. Manual inspection: searchWithFallback uses !searchResult.success for both providers
6. Manual inspection: addMetadataToResult accepts and passes fallbackReason
</verification>

<success_criteria>
- RequestMetadata type includes fallbackReason?: string
- formatRequestDetails displays fallback reason (not generic "Fallback provider used")
- searchWithFallback triggers fallback for ANY error, not just auth
- Fallback reason is extracted and surfaced in response
- When both providers fail, WebSearch suggestion is included
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-uat-gap-closure/06.1-01-SUMMARY.md`
</output>
